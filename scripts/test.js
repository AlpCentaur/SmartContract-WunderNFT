async function main() {
  const [deployer] = await ethers.getSigners();
  const address = "0x910e354A6B498bEEb7408abc8C59d94746EC24D5";
  const abi = ["constructor(bytes32 _keyHash, address _VRFCoordinator, address _linkToken)","event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)","event ApprovalForAll(address indexed owner, address indexed operator, bool approved)","event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)","event Paused(address account)","event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)","event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)","event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)","event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)","event Unpaused(address account)","event WunderPassMinted(uint256 indexed tokenId, address indexed owner, string status, string pattern, string wonder, string edition)","function ADMIN_ROLE() view returns (bytes32)","function DEFAULT_ADMIN_ROLE() view returns (bytes32)","function OWNER_ROLE() view returns (bytes32)","function _setTokenURI(uint256 tokenId, string _tokenURI)","function addAdmin(address _newAdmin)","function approve(address to, uint256 tokenId)","function balanceOf(address owner) view returns (uint256)","function bestStatusOf(address _owner) view returns (string status)","function bestWonderOf(address _owner) view returns (string wonder)","function changeOwner(address _newOwner)","function currentTokenId() view returns (uint256 id)","function editionThreshold() view returns (uint256)","function extendEditions(string[] _names, string[] _parents)","function getApproved(uint256 tokenId) view returns (address)","function getCounter(string _edition) view returns (uint256 count)","function getRoleAdmin(bytes32 role) view returns (bytes32)","function getWunderPass(uint256 tokenId) view returns (tuple(address owner, uint256 tokenId, string status, string edition, string wonder, string pattern) wunderpass)","function grantRole(bytes32 role, address account)","function hasRole(bytes32 role, address account) view returns (bool)","function isAdmin() view returns (bool)","function isApprovedForAll(address _owner, address _operator) view returns (bool isOperator)","function isOwner() view returns (bool)","function mint(string _edition) payable","function mintForUser(string _edition, address _owner)","function mintTest(string _edition, address _owner)","function name() view returns (string)","function owner() view returns (address)","function ownerOf(uint256 tokenId) view returns (address)","function pause()","function paused() view returns (bool)","function publicPrice() view returns (uint256)","function rawFulfillRandomness(bytes32 requestId, uint256 randomness)","function removeAdmin(address _admin)","function renounceOwnership()","function renounceRole(bytes32 role, address account)","function revokeRole(bytes32 role, address account)","function safeTransferFrom(address from, address to, uint256 tokenId)","function safeTransferFrom(address from, address to, uint256 tokenId, bytes _data)","function setApprovalForAll(address operator, bool approved)","function setChainlinkFee(uint256 _gweiPrice, uint256 _decimals)","function setEditionThreshold(uint256 _newThreshold)","function setOpenSeaProxyAddress(address _newAddress)","function setPublicPrice(uint256 _gweiPrice, uint256 _decimals)","function supportsInterface(bytes4 interfaceId) view returns (bool)","function symbol() view returns (string)","function thresholdUpperLimit() view returns (uint256)","function tokenURI(uint256 tokenId) view returns (string uri)","function tokensOfAddress(address _owner) view returns (uint256[] tokens)","function transferFrom(address from, address to, uint256 tokenId)","function transferOwnership(address newOwner)","function unpause()","function withdrawLink()","function withdrawMatic()"];

  const contract = await ethers.getContractAt("WunderNFT", address, deployer);
  // await contract.unpause();
  // await contract.extendEditions(['Berlin // DE // EU', 'Germany // EU', 'Europe', 'World'], ['Germany // EU', 'Europe', 'World', 'World']);
  await contract.mintForUser('Berlin // DE // EU', deployer.address);
  console.log(await contract.bestStatusOf(deployer.address))
}

main()
  .then(() => {
    process.exit(0)
  })
  .catch((err) => {
    console.error(err)
    process.exit(1)
  })